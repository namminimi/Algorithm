/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findMaxAverage = function(nums, k) {
    
    let n = nums.length;
    if (n < k) return null;

    // 초기 서브어레이의 합을 계산합니다.
    let maxSum = 0;
    for (let i = 0; i < k; i++) {
        maxSum += nums[i];
    }

    // 현재 최대 합을 최대 평균값으로 설정합니다.
    let currentSum = maxSum;

    // 슬라이딩 윈도우 기법을 사용하여 최대 평균을 계산합니다.
    for (let i = k; i < n; i++) {
        currentSum = currentSum - nums[i - k] + nums[i];
        maxSum = Math.max(maxSum, currentSum);
    }

    return maxSum / k;
    
    
    
    //let averageValue = -Infinity
    //let left = 0
    //let sum = 0
    //for(let right = 0; right < nums.length; right++){
     //   sum += nums[right]
      //  if(right - left +1 === k){
     //       averageValue = Math.max(averageValue, sum/k)
    
     //       sum -= nums[left]
     //       left++
     //   }
   // }
   // return averageValue
};


//슬라이딩 윈도우 기법의 핵심
//슬라이딩 윈도우 기법에서 우리는 일정한 크기의 부분 배열(윈도우)을 배열 전체를 순회하며 이동시킵니다. 이 때, 매번 전체 부분 배열을 새로 계산하지 않고, 이미 계산된 값을 활용하여 효율적으로 새로운 값을 계산합니다.

//예시로 설명해볼게요:
//우리에게 배열 [1, 12, -5, -6, 50, 3]와 k = 4가 있다고 가정해봅시다. 길이 4의 연속된 부분 배열 중 최대 평균을 찾는 문제입니다.

//단계별 설명
//초기 윈도우 설정:

//처음 4개의 숫자를 선택합니다: [1, 12, -5, -6]
//이 숫자들의 합을 구합니다: 1 + 12 + (-5) + (-6) = 2
//초기 합은 2입니다.
//윈도우를 한 칸 이동:

//이제 윈도우를 오른쪽으로 한 칸 이동시킵니다. 즉, 첫 번째 숫자 1을 제외하고, 다섯 번째 숫자 50을 포함합니다.
//새로운 윈도우는 [12, -5, -6, 50]입니다.
//이 윈도우의 합을 구하려면 전체를 다시 계산할 필요 없이 이전 합에서 첫 번째 숫자 1을 빼고 새로운 숫자 50을 더합니다: 2 - 1 + 50 = 51
//새로운 합은 51입니다.
//다시 한 칸 이동:

//다시 윈도우를 오른쪽으로 한 칸 이동시킵니다. 이번에는 두 번째 숫자 12를 제외하고, 여섯 번째 숫자 3을 포함합니다.
//새로운 윈도우는 [-5, -6, 50, 3]입니다.
//이 윈도우의 합을 구하려면 이전 합에서 두 번째 숫자 12를 빼고 새로운 숫자 3을 더합니다: 51 - 12 + 3 = 42
//새로운 합은 42입니다.
//이 과정을 반복하여 배열의 끝까지 이동합니다. 각 단계에서 윈도우의 합을 계산하고, 그 중 최대 값을 찾습니다.

//왜 한 칸씩 이동하나요?
//한 칸씩 이동하는 이유는 효율성 때문입니다. 전체 부분 배열을 매번 새로 계산하는 대신, 이미 계산된 값을 이용해 부분적으로 업데이트합니다. 이렇게 하면 시간 복잡도가 크게 줄어듭니다. 배열을 처음부터 끝까지 한 번만 순회하므로 시간 복잡도는 O(n)이 됩니다.